/**
 * @file    factor_set.cc
 * The implementation of a class used to represent a factor set.
 */

#include <assert.h>

#include "h2sl/common.h"
#include "h2sl/constraint.h"
#include "h2sl/world.h"
#include "h2sl/grounding.h"
#include "h2sl/object.h"
#include "h2sl/object_property.h"
#include "h2sl/index.h"
#include "h2sl/number.h"
#include "h2sl/phrase.h"
#include "h2sl/abstract_container.h"
#include "h2sl/region_abstract_container.h"
#include "h2sl/container.h"
#include "h2sl/region_container.h"
#include "h2sl/spatial_relation.h"

#include "h2sl/factor_set_adcg.h"

using namespace std;
using namespace h2sl;

bool
factor_set_adcg_solution_sort( const Factor_Set_Solution& a,
                              const Factor_Set_Solution& b ){
  return a.pygx() > b.pygx();
}

Factor_Set_ADCG::
Factor_Set_ADCG( const Phrase* phrase ) : Factor_Set( phrase ),
                                              _abstract_search_spaces() {
}

Factor_Set_ADCG::
~Factor_Set_ADCG() {

}

Factor_Set_ADCG::
Factor_Set_ADCG( const Factor_Set_ADCG& other ) : Factor_Set( other ),
                                             _abstract_search_spaces( other._abstract_search_spaces ) {

}


Factor_Set_ADCG&
Factor_Set_ADCG::
operator=( const Factor_Set_ADCG& other ) {
  _phrase = other._phrase;
  _child_factor_sets = other._child_factor_sets;
  _solutions = other._solutions;
  _abstract_search_spaces = other._abstract_search_spaces;
  return (*this);
}

void
Factor_Set_ADCG::
search( const Search_Space* searchSpace, 
        const Symbol_Dictionary& symbolDictionary,
        const World* world,
        LLM* llm,
        const unsigned int beamWidth,
        const bool& debug ){
  search( searchSpace, symbolDictionary, world, NULL, llm, beamWidth, debug );
  return;
}

void
Factor_Set_ADCG::
search( const Search_Space* searchSpace, 
        const Symbol_Dictionary& symbolDictionary,
        const World* world,
        const Grounding* context,
        LLM* llm,
        const unsigned int beamWidth,
        const bool& debug ){
  //_search_physical( searchSpace, symbolDictionary, world, llm, beamWidth, debug );

  /**************** CREATE CHILD SOLUTION COMBOS ***********************/

  // Create the vector that will have the child solutions indices.      
  vector< vector< unsigned int > > child_solution_indices;
  for( unsigned int i = 0; i < _child_factor_sets.size(); i++ ){
    child_solution_indices.push_back( vector< unsigned int >() );
    for( unsigned int j = 0; j < _child_factor_sets[ i ]->solutions().size(); j++ ){
      child_solution_indices.back().push_back( j );
    }
  }

  // Create the indices for the child solution combos (power set).
  vector< vector< unsigned int > > child_solution_indices_cartesian_power = cartesian_power( child_solution_indices );
  if( child_solution_indices_cartesian_power.empty() ){
    child_solution_indices_cartesian_power.push_back( vector< unsigned int >() );
  }

  vector< bool > evaluate_feature_types( NUM_FEATURE_TYPES, true );

  if( debug ){
    cout << "concrete search space" << endl;
    for( map< string, pair< string, vector< Grounding* > > >::const_iterator it_search_spaces = searchSpace->grounding_pairs().begin(); it_search_spaces != searchSpace->grounding_pairs().end(); it_search_spaces++ ){
      cout << "searching through symbols for \"" << it_search_spaces->first << "\" (" << it_search_spaces->second.second.size() << " symbols)" << endl;
    }
  }

  /**************** MARCH THROUGH THE CHILD SOLUTION COMBOS***********************/

 vector< vector< Factor_Set_Solution > > solutions_vector;
  // add a Factor_Set_Solution for each combination of children
  for( unsigned int i = 0; i < child_solution_indices_cartesian_power.size(); i++ ){
    solutions_vector.push_back( vector< Factor_Set_Solution >() );

    // start with an empty solution vector, set the childen equal to the children generated by the cartesian power
    solutions_vector.back().push_back( Factor_Set_Solution() );
    solutions_vector.back().back().child_solution_indices() = child_solution_indices_cartesian_power[ i ];

    // generate the child groundings for the cartesian power
    vector< pair< const Phrase*, vector< Grounding* > > > child_groundings;
    for( unsigned int j = 0; j < child_solution_indices_cartesian_power[ i ].size(); j++ ){
      solutions_vector.back().back().pygx() *= _child_factor_sets[ j ]->solutions()[ child_solution_indices_cartesian_power[ i ][ j ] ].pygx();
      child_groundings.push_back( pair< const Phrase*, vector< Grounding* > >( _child_factor_sets[ j ]->phrase(), _child_factor_sets[ j ]->solutions()[ child_solution_indices_cartesian_power[ i ][ j ] ].grounding_set()->groundings() ) );
    }

    // search over all of the class-based search spaces
    for( map< string, pair< string, vector< Grounding* > > >::const_iterator it_search_spaces = searchSpace->grounding_pairs().begin(); it_search_spaces != searchSpace->grounding_pairs().end(); it_search_spaces++ ){
      map< string, vector< string > >::const_iterator it_cvs = searchSpace->cvs().find( it_search_spaces->second.first );
      assert( it_cvs != searchSpace->cvs().end() );

      // search the subspace that incrementally populates the solution vectors
      search_subspace( solutions_vector.back(),
                        child_groundings,
                        it_search_spaces->second,
                        it_cvs->second,
                        evaluate_feature_types,
                        context, world, llm, beamWidth, debug );

    }
 
    // Symbol dictionaries for the current inference with the child solution combo.
    vector< pair< double, Symbol_Dictionary > > inferred_concrete_symbol_dictionaries;
    // Iterate and scrape the groundings from the solutions found. Record the probabilities.
    for( vector< Factor_Set_Solution >::const_iterator it_solution = solutions_vector.back().begin(); it_solution !=  solutions_vector.back().end(); it_solution++) {
      inferred_concrete_symbol_dictionaries.push_back( pair< double, Symbol_Dictionary >( it_solution->pygx(), Symbol_Dictionary( symbolDictionary, "abstract" ) ) );
      cout << "current grounding set (" << *it_solution->grounding_set() << ")" << endl;
      it_solution->grounding_set()->scrape_grounding( world, 
                                                     inferred_concrete_symbol_dictionaries.back().second.string_types(), 
                                                     inferred_concrete_symbol_dictionaries.back().second.int_types() );
      inferred_concrete_symbol_dictionaries.back().second.class_names() = symbolDictionary.class_names();
    }     

    for( vector< pair< double, Symbol_Dictionary > >::const_iterator it_symbol_dictionary = inferred_concrete_symbol_dictionaries.begin(); it_symbol_dictionary != inferred_concrete_symbol_dictionaries.end(); it_symbol_dictionary++ ){
    // Print out for debug.
      if( debug ){
        cout << "inferred concrete symbol dictionary (" << it_symbol_dictionary->first << "):(" << it_symbol_dictionary->second << ")" << endl;
      }
   
      // Creating the ssearch space from the symbol dictionary with abstract flag on.
      _abstract_search_spaces.push_back( new Search_Space() );
      _abstract_search_spaces.back()->fill_groundings( it_symbol_dictionary->second, world, "abstract" );

      // Print out the abstract search space.
      if( debug ){
        cout << "abstract search space" << endl;
        for( map< string, pair< string, vector< Grounding* > > >::const_iterator it_search_spaces = _abstract_search_spaces.back()->grounding_pairs().begin(); it_search_spaces != _abstract_search_spaces.back()->grounding_pairs().end(); it_search_spaces++ ){
          cout << "searching through symbols for \"" << it_search_spaces->first << "\" (" << it_search_spaces->second.second.size() << " symbols)" << endl;
        }
      }


      // search over the class-based search spaces for the abstract symbols.
      for( map< string, pair< string, vector< Grounding* > > >::const_iterator it_abstract_search_spaces = _abstract_search_spaces.back()->grounding_pairs().begin(); it_abstract_search_spaces != _abstract_search_spaces.back()->grounding_pairs().end(); it_abstract_search_spaces++ ){
        map< string, vector< string > >::const_iterator it_abstract_cvs = _abstract_search_spaces.back()->cvs().find( it_abstract_search_spaces->second.first );
        assert( it_abstract_cvs != _abstract_search_spaces.back()->cvs().end() );

        // search the subspace that incrementally populates the solution vectors
        search_subspace( solutions_vector.back(),
                        child_groundings,
                        it_abstract_search_spaces->second,
                        it_abstract_cvs->second,
                        evaluate_feature_types,
                        context, world, llm, beamWidth, debug );

      }

    }
  }

  /**************** FLATTEN THE SOLUTIONS ***********************/
  _solutions.clear();
  for( unsigned int i = 0; i < solutions_vector.size(); i++ ){
    for( unsigned int j = 0; j < solutions_vector[ i ].size(); j++ ){
      _solutions.push_back( solutions_vector[ i ][ j ] );
    }
  }


  /**************** SORT AND TRIM SOLUTIONS ***********************/
  if( debug ){
    cout << "  sorting through " << _solutions.size() << " solutions for \"" << _phrase->words_to_std_string() << "\"" << endl;
  }

  sort( _solutions.begin(), _solutions.end(), factor_set_adcg_solution_sort );
  if( _solutions.size() > beamWidth ){
    _solutions.erase( _solutions.begin() + beamWidth, _solutions.end() );
  }
 
  /**************** PRINT OUT THE SOLUTIONS IF REQD.***********************/

  if( debug ){
    for( unsigned int i = 0; i < _solutions.size(); i++ ){
      cout << "solution[" << i << "] (pygx:" << _solutions[ i ].pygx() << ")" << endl;
      cout << "  grounding_set" << *_solutions[ i ].grounding_set() << endl;
      cout << "  child_solution_indices[" << _solutions[ i ].child_solution_indices().size() << "]:{";
      for( unsigned int j = 0; j < _solutions[ i ].child_solution_indices().size(); j++ ){
        cout << "(\"" << _child_factor_sets[ j ]->phrase()->words_to_std_string() << "\":" << _solutions[ i ].child_solution_indices()[ j ] << ")";
        if( j != ( _solutions[ i ].child_solution_indices().size() - 1 ) ){
          cout << ",";
        }
      }
      cout << "}" << endl;
      cout << "  child grounding_sets[" << _solutions[ i ].child_solution_indices().size() << "]:{";
      for( unsigned int j = 0; j < _solutions[ i ].child_solution_indices().size(); j++ ){
        cout <<  "(\"" << _child_factor_sets[ j ]->phrase()->words_to_std_string() << "\":(groundings" << *_child_factor_sets[ j ]->solutions()[ _solutions[ i ].child_solution_indices()[ j ] ].grounding_set() << "))";
        if( j != ( _solutions[ i ].child_solution_indices().size() - 1 ) ){
          cout << ",";
        }
      }
      cout << "}" << endl;
    }
  }

  return;
}


/*
void
Factor_Set_ADCG::
_search_physical( const Search_Space& searchSpace, 
                  const Symbol_Dictionary& symbolDictionary,
                  const World* world, LLM* llm, const unsigned int beamWidth, const bool& debug ){
  if( debug ){
    cout << " Factor Set ADCG: Beginning of physical search" << endl;
    cout << " phrase:" << *_phrase << endl;
  }

  // Abstract search space data structure: clearing them. 
  for( unsigned int i = 0; i < _abstract_search_spaces.size(); i++ ){
    for( unsigned int j = 0; j < _abstract_search_spaces[ i ].size(); j++ ){
      if( _abstract_search_spaces[ i ][ j ].second != NULL ){
        delete _abstract_search_spaces[ i ][ j ].second;
        _abstract_search_spaces[ i ][ j ].second = NULL;
      }
    }
    _abstract_search_spaces[ i ].clear();
  }
  _abstract_search_spaces.clear();

  // Form the child solution indices vector.
  vector< vector< unsigned int > > child_solution_indices;
  for( unsigned int i = 0; i < _children.size(); i++ ){
    child_solution_indices.push_back( vector< unsigned int >() );
    for( unsigned int j = 0; j < _children[ i ]->solutions().size(); j++ ){
      child_solution_indices.back().push_back( j );
    }
  }

  // Create the child solution indices cartesian power vector.
  vector< vector< unsigned int > > child_solution_indices_cartesian_power = cartesian_power( child_solution_indices );
  if( child_solution_indices_cartesian_power.empty() ){
    child_solution_indices_cartesian_power.push_back( vector< unsigned int >() );
  }

  // Resize the abstract search space with the child solution cartesian power set.
  _abstract_search_spaces.resize( child_solution_indices_cartesian_power.size() );

  // Evaluate feature types vector. True.
  vector< bool > evaluate_feature_types( NUM_FEATURE_TYPES, true );

  // Create the factor set solutions vector 
  vector< vector< Factor_Set_Solution > > solutions_vector;
  for( unsigned int i = 0; i < child_solution_indices_cartesian_power.size(); i++ ){
    solutions_vector.push_back( vector< Factor_Set_Solution >() );
    solutions_vector.back().push_back( Factor_Set_Solution() );
    solutions_vector.back().back().children = child_solution_indices_cartesian_power[ i ];
    //solutions_vector.back().back().cv.resize( NUM_CVS );

    vector< pair< const Phrase*, vector< Grounding* > > > child_groundings;
    for( unsigned int j = 0; j < child_solution_indices_cartesian_power[ i ].size(); j++ ){
      solutions_vector.back().back().pygx *= _children[ j ]->solutions()[ child_solution_indices_cartesian_power[ i ][ j ] ].pygx;
      child_groundings.push_back( pair< const Phrase*, vector< Grounding* > >( _children[ j ]->phrase(), vector< Grounding* >() ) );
      for( unsigned int k = 0; k < _children[ j ]->solutions()[ child_solution_indices_cartesian_power[ i ][ j ] ].groundings->groundings().size(); k++ ){
        child_groundings.back().second.push_back( _children[ j ]->solutions()[ child_solution_indices_cartesian_power[ i ][ j ] ].groundings->groundings()[ k ] );
      }
    }

    for( map< string, pair< string, vector< Grounding* > > >::const_iterator it_search_spaces = searchSpace.grounding_pairs().begin(); it_search_spaces != searchSpace.grounding_pairs().end(); it_search_spaces++ ){
      for( unsigned int j = 0; it_search_spaces->second.second.size(); j++ ){
        unsigned int num_solutions = solutions_vector.back().size();
        map< string, vector< unsigned int > >::const_iterator it_cvs = searchSpace.cvs().find( it_search_spaces->second.first );
        assert( it_cvs != searchSpace.cvs().end() );

        for( unsigned int k = 1; k < it_cvs->second.size(); k++ ){
          for( unsigned int l = 0; l < num_solutions; l++ ){
            solutions_vector.back().push_back( solutions_vector.back()[ l ] );
          }
        }

        // Prob. of individual factors. Context of child groundings. Multiply with the child groundings.
        for( unsigned int k = 0; k < it_cvs->second.size() ; k++ ){
          double value = llm->pygx( it_cvs->second[ k ], it_search_spaces->second.second[ j ], child_groundings, _phrase, world, it_cvs->second, evaluate_feature_types );
          evaluate_feature_types[ FEATURE_TYPE_LANGUAGE ] = false;
          for( unsigned int l = 0; l < num_solutions; l++ ){
            map< string, vector< vector< unsigned int > > >::iterator it_cvs_solution = solutions_vector.back()[ k* num_solutions + l ].cv.find( it_search_spaces->first );
            //assert( it_cvs_solution != solutions_vector.back()[ k * num_solutions + l ].cv.end() );
            //solutions_vector.back()[ k * num_solutions + l ].cv[ correspondenceVariables[ searchSpace[ j ].first ][ k ] ].push_back( j );
            solutions_vector.back()[ k * num_solutions + l ].pygx *= value;
          }
        }

        // Most probable set. Trim the solutions.
        sort( solutions_vector.back().begin(), solutions_vector.back().end(), factor_set_adcg_solution_sort );
        if( solutions_vector.back().size() > beamWidth ){
          solutions_vector.back().erase( solutions_vector.back().begin() + beamWidth, solutions_vector.back().end() );
        }

        for( unsigned int k = 0; k < solutions_vector.back().size(); k++ ){
          solutions_vector.back()[ k ].groundings->groundings().clear();
     //     for( unsigned int l = 0; l < solutions_vector.back()[ k ].cv[ CV_TRUE ].size(); l++ ){
       //     solutions_vector.back()[ k ].groundings.push_back( searchSpace[ solutions_vector.back()[ k ].cv[ CV_TRUE ][ l ] ].second );
            //solutions_vector.back()[ k ].groundings.push_back( it_search_spaces->second.second[ solutions_vector.back()[ k ].cv[ CV_TRUE ][ l ] ] );
     //     }
        }


      }
    }
  //}


   vector< Symbol_Dictionary > estimated_symbol_dictionaries;
   

    // look for the expressed symbols for objects, indices
    vector< vector< unsigned int > > observed_true_solution_vectors;
    vector< vector< Object* > > observed_object_vectors;
    vector< string > observed_spatial_relations( 1, string( "na" ) );
    vector< string > observed_object_types( 1, string( "na" ) );
    vector< string > observed_object_colors( 1, string( "na") );
    vector< int > observed_indices( 1, 1 );
    vector< int > observed_numbers; 
  
    // Collect the solutions at the concrete level. 
    for( unsigned int k = 0; k < solutions_vector.back().size(); k++ ){
      // look for a new observed_new_solution_vector
      bool new_true_solution_vector = true;
      for( unsigned int l = 0; l < observed_true_solution_vectors.size(); l++ ){
        if( solutions_vector.back()[ k ].cv[ CV_TRUE ] == observed_true_solution_vectors[ l ] ){
          new_true_solution_vector = false;
        }
      }
      if( new_true_solution_vector ){
        observed_true_solution_vectors.push_back( solutions_vector.back()[ k ].cv[ CV_TRUE ] );
        observed_object_vectors.push_back( vector< Object* >() );

        for( unsigned int m = 0; m < solutions_vector.back()[ k ].cv[ CV_TRUE ].size(); m++ ){
          if( dynamic_cast< Object* >( searchSpace[ solutions_vector.back()[ k ].cv[ CV_TRUE ][ m ] ].second ) != NULL ){
            observed_object_vectors.back().push_back( static_cast< Object* >( searchSpace[ solutions_vector.back()[ k ].cv[ CV_TRUE ][ m ] ].second ) );
          } else if ( dynamic_cast< Index* >( searchSpace[ solutions_vector.back()[ k ].cv[ CV_TRUE ][ m ] ].second ) != NULL ){
            int tmp = static_cast< Index* >( searchSpace[ solutions_vector.back()[ k ].cv[ CV_TRUE ][ m ] ].second )->value();
            if( find( observed_indices.begin(), observed_indices.end(), tmp ) == observed_indices.end() ){
              observed_indices.push_back( tmp );
            }
          } else if ( dynamic_cast< Number* >( searchSpace[ solutions_vector.back()[ k ].cv[ CV_TRUE ][ m ] ].second ) != NULL ){
            int tmp_number = static_cast< Number* >( searchSpace[ solutions_vector.back()[ k ].cv[ CV_TRUE ][ m ] ].second )->value();
            if( find( observed_numbers.begin(), observed_numbers.end(), tmp_number ) == observed_numbers.end() ){
              observed_numbers.push_back( tmp_number );
            }
          } else if ( dynamic_cast< Object_Type* >( searchSpace[ solutions_vector.back()[ k ].cv[ CV_TRUE ][ m ] ].second ) != NULL ){
            string tmp_object_type = static_cast< Object_Type* >( searchSpace[ solutions_vector.back()[ k ].cv[ CV_TRUE ][ m ] ].second )->type();
            if( find( observed_object_types.begin(), observed_object_types.end(), tmp_object_type ) == observed_object_types.end() ){
              observed_object_types.push_back( tmp_object_type );
            }
          } else if ( dynamic_cast< Object_Color* >( searchSpace[ solutions_vector.back()[ k ].cv[ CV_TRUE ][ m ] ].second ) != NULL ){
            string tmp_object_color = static_cast< Object_Color* >( searchSpace[ solutions_vector.back()[ k ].cv[ CV_TRUE ][ m ] ].second )->object_color_type();
            if( find( observed_object_colors.begin(), observed_object_colors.end(), tmp_object_color ) == observed_object_colors.end() ){
              observed_object_colors.push_back( tmp_object_color );
            }
          } else if ( dynamic_cast< Spatial_Relation* >( searchSpace[ solutions_vector.back()[ k ].cv[ CV_TRUE ][ m ] ].second ) != NULL ){
            string tmp_spatial_relation = static_cast< Spatial_Relation* >( searchSpace[ solutions_vector.back()[ k ].cv[ CV_TRUE ][ m ] ].second )->spatial_relation_type();
            if( find( observed_spatial_relations.begin(), observed_spatial_relations.end(), tmp_spatial_relation ) == observed_spatial_relations.end() ){
              observed_spatial_relations.push_back( tmp_spatial_relation );
            }
          } else if ( dynamic_cast< Abstract_Container* >( searchSpace[ solutions_vector.back()[ k ].cv[ CV_TRUE ][ m ] ].second ) != NULL ){
            Abstract_Container* tmp_abstract_container = static_cast< Abstract_Container* >( searchSpace[ solutions_vector.back()[ k ].cv[ CV_TRUE ][ m ] ].second );
            int tmp_number =  tmp_abstract_container->number() ;
            if( find( observed_numbers.begin(), observed_numbers.end(), tmp_number ) == observed_numbers.end() ){
              observed_numbers.push_back( tmp_number );
            }
            int tmp_index =  tmp_abstract_container->index();
            if( find( observed_indices.begin(), observed_indices.end(), tmp_index ) == observed_indices.end() ){
              observed_indices.push_back( tmp_index );
            }
            string tmp_object_type = tmp_abstract_container->type();
            if( find( observed_object_types.begin(), observed_object_types.end(), tmp_object_type ) == observed_object_types.end() ){
              observed_object_types.push_back( tmp_object_type );
            }
            string tmp_object_color = tmp_abstract_container->color();
            if( find( observed_object_colors.begin(), observed_object_colors.end(), tmp_object_color ) == observed_object_colors.end() ){
              observed_object_colors.push_back( tmp_object_color );
            }
          }
        }

        // Looking for pairs of objects. If there is only one then do not.
        if( observed_object_vectors.back().size() < 2 ){
          observed_object_vectors.pop_back();
        }
   
        // If the solution vectors are identical, remove them. 
        if( observed_object_vectors.size() > 1 ){
          for( unsigned m = 0; m < ( observed_object_vectors.size() - 1 ); m++ ){
            if( observed_object_vectors[ m ] == observed_object_vectors.back() ){
              observed_object_vectors.pop_back();
            }
          }
        }
      }
    }

    // add in the observed indices from the children
    for( unsigned int j = 0; j < child_groundings.size(); j++ ){
      for( unsigned int k = 0; k < child_groundings[ j ].second.size(); k++ ){
        if( dynamic_cast< Index* >( child_groundings[ j ].second[ k ] ) != NULL ){
          int tmp = static_cast< Index* >( child_groundings[ j ].second[ k ] )->value();
          if( find( observed_indices.begin(), observed_indices.end(), tmp ) == observed_indices.end() ){
            observed_indices.push_back( tmp );
          }
        } else if ( dynamic_cast< Object_Property* >( child_groundings[ j ].second[ k ] ) != NULL ){
          Object_Property* tmp_object_property = static_cast< Object_Property* >( child_groundings[ j ].second[ k ] );
          int tmp_index = tmp_object_property->index();
          if( find( observed_indices.begin(), observed_indices.end(), tmp_index ) == observed_indices.end() ){
            observed_indices.push_back( tmp_index );
          }
          string tmp_object_type = tmp_object_property->type();
          if( find( observed_object_types.begin(), observed_object_types.end(), tmp_object_type ) == observed_object_types.end() ){
            observed_object_types.push_back( tmp_object_type );
          }
          string tmp_spatial_relation = tmp_object_property->relation_type();
          if( find( observed_spatial_relations.begin(), observed_spatial_relations.end(), tmp_spatial_relation ) == observed_spatial_relations.end() ){
            observed_spatial_relations.push_back( tmp_spatial_relation );
          }
        } else if ( dynamic_cast< Spatial_Relation* >( child_groundings[ j ].second[ k ] ) != NULL ){
          string tmp_spatial_relation = static_cast< Spatial_Relation* >( child_groundings[ j ].second[ k ] )->spatial_relation_type();
          if( find( observed_spatial_relations.begin(), observed_spatial_relations.end(), tmp_spatial_relation ) == observed_spatial_relations.end() ){
            observed_spatial_relations.push_back( tmp_spatial_relation );
          }
        } else if ( dynamic_cast< Region_Container* >( child_groundings[ j ].second[ k ] ) != NULL ){
          string tmp_spatial_relation = static_cast< Region_Container* >( child_groundings[ j ].second[ k ] )->relation_type();
          if( find( observed_spatial_relations.begin(), observed_spatial_relations.end(), tmp_spatial_relation ) == observed_spatial_relations.end() ){
            observed_spatial_relations.push_back( tmp_spatial_relation );
          }
        }
      }
    }

    if ( world != NULL) {
      // TODO CHECK THIS
      for( map< string, vector< Object* > >::const_iterator it1 = world->sorted_objects().end()->second.begin(); it1 != world->sorted_objects().end()->second.end(); it1++ ){
        int tmp_number = it1->second.size();
        if( tmp_number != 0 ){
          if( find( observed_numbers.begin(), observed_numbers.end(), tmp_number ) == observed_numbers.end() ){
            observed_numbers.push_back( tmp_number );
          }
        }
      }  
    }   

  // TODO: NEED TO ACCOUNT FOR OTHER EXPRESSIONS OF THE CONTAINERS HERE, ADD TO ALL SOLUTIONS
    // fill search space
     
    map< string, vector< string > >::const_iterator it_symbol_dictionary_container = symbolDictionary.string_types().find( string( "container" ) );
    map< string, vector< string > >::const_iterator it_symbol_dictionary_spatial_relation = symbolDictionary.string_types().find( string( "spatial_relation" ) );
    map< string, vector< int > >::const_iterator it_symbol_dictionary_index = symbolDictionary.int_types().find( string( "index" ) );

 
    if ( it_symbol_dictionary_container != symbolDictionary.string_types().end() ) {
      for( unsigned int j = 0; j < it_symbol_dictionary_container->second.size(); j++ ) {
        for( unsigned int k = 0; k < observed_object_vectors.size(); k++ ) {
          vector< Grounding* > observed_object_grounding_vectors;
          for ( unsigned int m = 0; m < observed_object_vectors[ k ].size(); m++ ) {
            if ( dynamic_cast< Grounding* >( observed_object_vectors[ k ][ m ] ) != NULL ) {
             observed_object_grounding_vectors.push_back( observed_object_vectors[ k ][ m ] );
            }
          }
          _abstract_search_spaces[ i ].push_back( pair< unsigned int, Grounding* >( 0, new Container( 
                                                                                             observed_object_grounding_vectors, 
                                                                                             it_symbol_dictionary_container->second[ j ] ) ) );
        }
      }  
    }

    // Create the space of abstract containers.
    if ( it_symbol_dictionary_spatial_relation != symbolDictionary.string_types().end() && it_symbol_dictionary_container != symbolDictionary.string_types().end() )  {
      // Iterate over spatial relation
      //for( unsigned int j = 0; j < it1->second.size(); j++ ) {
      for( unsigned int j = 0; j < observed_spatial_relations.size(); j++ ) {
        // Iterate over container types
        for( unsigned int k = 0; k < it_symbol_dictionary_container->second.size(); k++ ) {
          for( unsigned int l = 0; l < observed_object_vectors.size(); l++ ) {
            vector< Grounding* > observed_object_grounding_vectors;
            for ( unsigned int m = 0; m < observed_object_vectors[ l ].size(); m++ ) {
              if ( dynamic_cast< Grounding* >( observed_object_vectors[ l ][ m ]) != NULL ) {
                observed_object_grounding_vectors.push_back( observed_object_vectors[ l ][ m ] );
              }
            }
            _abstract_search_spaces[ i ].push_back( pair< unsigned int, Grounding* >( 0, new Region_Container( 
                                                                                               observed_spatial_relations[ j ], 
                                                                                               Container( observed_object_grounding_vectors, 
                                                                                                          it_symbol_dictionary_container->second[ k ] ) ) ) );
          } 
        }
      }   
    }

   // Create the space of Object Property symbols.
    for( unsigned int j = 0; j < observed_object_types.size(); j++ ){
      for( unsigned int k = 0; k < observed_spatial_relations.size(); k++ ){
        for( unsigned int l = 0; l < observed_indices.size(); l++ ){
          _abstract_search_spaces[ i ].push_back( pair< unsigned int, Grounding* >( 0, new Object_Property( 
                                                                                             observed_object_types[ j ], 
                                                                                             observed_spatial_relations[ k ], 
                                                                                             observed_indices[ l ] ) ) );
        }
      }
    }

    // Create the space of Abstract Containers and Region Abstract Containers.
    if ( it_symbol_dictionary_index != symbolDictionary.int_types().end() ) {
      for( unsigned int j = 0; j < observed_object_types.size(); j++ ){
        for( unsigned int k = 0; k < observed_numbers.size(); k++ ){
          for( unsigned int l = 0; l < observed_object_colors.size(); l++ ){
            _abstract_search_spaces[ i ].push_back( pair< unsigned int, Grounding* >( 0, new Abstract_Container( 
                                                                                               observed_object_types[ j ], 
                                                                                               observed_numbers[ k ], 
                                                                                               it_symbol_dictionary_index->second.front(), //Index::TYPE_FIRST, 
                                                                                               observed_object_colors[ l ] ) ) );
            for( unsigned int m = 0; m < observed_spatial_relations.size(); m++ ){
              _abstract_search_spaces[ i ].push_back( pair< unsigned int, Grounding* >( 0, new Region_Abstract_Container( 
                                                                                               observed_spatial_relations[ m ], 
                                                                                               observed_object_types[ j ], 
                                                                                                                   observed_numbers[ k ], 
                                                                                                                   it_symbol_dictionary_index->second.front(), //Index::TYPE_FIRST, 
                                                                                                                   observed_object_colors[ l ] ) ) );
            }
          }
        }
      }
    }
 
    // search
    for( unsigned int j = 0; j < _abstract_search_spaces[ i ].size(); j++ ){
      unsigned int num_solutions = solutions_vector.back().size();
      for( unsigned int k = 1; k < _abstract_correspondence_variables[ _abstract_search_spaces[ i ][ j ].first ].size(); k++ ){
        for( unsigned int l = 0; l < num_solutions; l++ ){
          solutions_vector.back().push_back( solutions_vector.back()[ l ] );
        }
      }

      for( unsigned int k = 0; k < _abstract_correspondence_variables[ _abstract_search_spaces[ i ][ j ].first ].size(); k++ ){
        double value = llm->pygx( _abstract_correspondence_variables[ _abstract_search_spaces[ i ][ j ].first ][ k ], _abstract_search_spaces[ i ][ j ].second, child_groundings, _phrase, world, _abstract_correspondence_variables[ _abstract_search_spaces[ i ][ j ].first ], evaluate_feature_types );
        evaluate_feature_types[ FEATURE_TYPE_LANGUAGE ] = false;
        for( unsigned int l = 0; l < num_solutions; l++ ){
          solutions_vector.back()[ k * num_solutions + l ].cv[ _abstract_correspondence_variables[ _abstract_search_spaces[ i ][ j ].first ][ k ] ].push_back( searchSpace.size() + j );
          solutions_vector.back()[ k * num_solutions + l ].pygx *= value;
        }
      }

      sort( solutions_vector.back().begin(), solutions_vector.back().end(), factor_set_adcg_solution_sort );
      if( solutions_vector.back().size() > beamWidth ){
        solutions_vector.back().erase( solutions_vector.back().begin() + beamWidth, solutions_vector.back().end() );
      }

      for( unsigned int k = 0; k < solutions_vector.back().size(); k++ ){
        solutions_vector.back()[ k ].groundings.clear();
        for( unsigned int l = 0; l < solutions_vector.back()[ k ].cv[ CV_TRUE ].size(); l++ ){
          if( solutions_vector.back()[ k ].cv[ CV_TRUE ][ l ] < searchSpace.size() ){
            // add the symbol from the normal search space
            solutions_vector.back()[ k ].groundings.push_back( searchSpace[ solutions_vector.back()[ k ].cv[ CV_TRUE ][ l ] ].second );
          } else {
            // add the symbol from the abstract search space
            solutions_vector.back()[ k ].groundings.push_back( _abstract_search_spaces[ i ][ solutions_vector.back()[ k ].cv[ CV_TRUE ][ l ] - searchSpace.size() ].second );
          }
        }
      }
    }

  }
  // flatten solutions
  _solutions.clear();
  for( unsigned int i = 0; i < solutions_vector.size(); i++ ){
    for( unsigned int j = 0; j < solutions_vector[ i ].size(); j++ ){
      _solutions.push_back( solutions_vector[ i ][ j ] );
    }
  }

  if( debug ){
    cout << "  sorting through " << _solutions.size() << " solutions for \"" << _phrase->words_to_std_string() << "\"" << endl;
  }

  sort( _solutions.begin(), _solutions.end(), factor_set_adcg_solution_sort );
  if( _solutions.size() > beamWidth ){
    _solutions.erase( _solutions.begin() + beamWidth, _solutions.end() );
  }


  if( debug ){
    cout << *this << endl;
  }

  return;
  
}
*/


namespace h2sl {
  ostream&
  operator<<( ostream& out,
              const Factor_Set_ADCG& other ){
    return out;
  }
}






































